rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    // Helper functions for role checking
    function isDietitian(userId) {
      return exists(/databases/$(database)/documents/userRoles/$(userId)) &&
             (get(/databases/$(database)/documents/userRoles/$(userId)).data.role == 'dietitian' ||
              get(/databases/$(database)/documents/userRoles/$(userId)).data.role == 'admin');
    }
    
    function isAdmin(userId) {
      return exists(/databases/$(database)/documents/userRoles/$(userId)) &&
             get(/databases/$(database)/documents/userRoles/$(userId)).data.role == 'admin';
    }
    // Users: allow authenticated read of basic user docs; write limited to owner
    match /users/{userId} {
      allow read: if request.auth != null;
      allow create: if request.auth != null && request.auth.uid == userId;
      allow update, delete: if request.auth != null && request.auth.uid == userId;
      
      // User settings subcollection
      match /settings/{settingId} {
        // Owner can read/write their own settings
        allow read, write: if request.auth != null && request.auth.uid == userId;
      }
    }

    // Chats collection
    match /chats/{chatId} {
      // Helpers: participant checks for read vs write
      function isParticipantResource() {
        return request.auth != null &&
               resource.data.participants != null &&
               resource.data.participants is list &&
               resource.data.participants.hasAny([request.auth.uid]);
      }
      function isParticipantRequest() {
        return request.auth != null &&
               request.resource.data.participants != null &&
               request.resource.data.participants is list &&
               request.resource.data.participants.hasAny([request.auth.uid]);
      }

      // Read chat doc if participant (per-document evaluation)
      allow get: if request.auth != null;
      
      // Allow listing chats where user is in participants array
      allow list: if request.auth != null;

      // Create chat if participant and fields constrained
      allow create: if request.auth != null &&
        request.resource.data.participants is list &&
        request.resource.data.participants.hasAny([request.auth.uid]) &&
        request.resource.data.keys().hasOnly([
          'chatId','participants','participantNames','lastMessage','lastMessageTime',
          'isLastMessageFromMe','isLastMessageRead','updatedAt','createdAt',
          'unreadCount','unreadCountByUser','isPinned','isMuted','isArchived',
          'tags','typingUsers','pinnedMessageIds',
          // group specific fields
          'isGroup','groupId','groupName','groupImage','groupDescription','type'
        ]) &&
        request.resource.data.chatId == chatId;

      allow update: if (
        // Mevcut participant ise
        (isParticipantResource()) ||
        // Yeni chat oluşturuluyor ve kullanıcı participant listesinde ise
        (request.auth != null && 
         request.resource.data.participants != null &&
         request.resource.data.participants is list &&
         request.resource.data.participants.hasAny([request.auth.uid]))
      ) && request.resource.data.diff(resource.data).changedKeys().hasOnly([
          'lastMessage','lastMessageTime','isLastMessageFromMe','isLastMessageRead',
          'updatedAt','unreadCount','unreadCountByUser','isPinned','isMuted','isArchived',
          'tags','typingUsers','pinnedMessageIds','participantNames','deletedFor','deletedAtByUser',
          // allow group chat meta updates
          'groupName','groupImage','groupDescription','participants','type','isGroup'
        ]);

      // Messages subcollection
      match /messages/{messageId} {
        function parentIsParticipant() {
          return request.auth != null &&
                 exists(/databases/$(database)/documents/chats/$(chatId)) &&
                 get(/databases/$(database)/documents/chats/$(chatId)).data.participants != null &&
                 get(/databases/$(database)/documents/chats/$(chatId)).data.participants is list &&
                 get(/databases/$(database)/documents/chats/$(chatId)).data.participants
                   .hasAny([request.auth.uid]);
        }

        allow get, list: if parentIsParticipant();

        // Create message by sender; basic field checks
        allow create: if parentIsParticipant() &&
          request.resource.data.keys().hasOnly([
            'messageId','chatId','senderId','recipientId','text','type','timestamp',
            'isRead','isDelivered','isEdited','createdAt','replyToMessageId',
            'replyToText','replyToSenderId','mediaUrl','fileName','latitude','longitude',
            'locationName','deliveredAt','readAt','deletedFor','editedAt','mediaLocalPath',
            // group message specific fields
            'isGroupMessage','groupId','groupMembers'
          ]) &&
          request.resource.data.chatId == chatId &&
          request.resource.data.senderId == request.auth.uid;

        // Update only non-critical fields
        allow update: if parentIsParticipant() &&
          request.resource.data.diff(resource.data).changedKeys().hasOnly([
            'isRead','readAt','isDelivered','deliveredAt','isEdited','editedAt',
            'text','deletedFor'
          ]);

        allow delete: if parentIsParticipant() && resource.data.senderId == request.auth.uid;
      }
    }

    // Groups collection
    match /groups/{groupId} {
      function isGroupMember() {
        return request.auth != null &&
          get(/databases/$(database)/documents/groups/$(groupId)).data.members
            .hasAny([request.auth.uid]);
      }

      function isGroupAdmin() {
        return request.auth != null &&
          get(/databases/$(database)/documents/groups/$(groupId)).data.admins
            .hasAny([request.auth.uid]);
      }

      // Read group if member
      allow get, list: if isGroupMember();

      // Create group by creator; ensure creator is in members and admins
      allow create: if request.auth != null &&
        request.resource.data.createdBy == request.auth.uid &&
        request.resource.data.members is list &&
        request.resource.data.admins is list &&
        request.resource.data.members.hasAny([request.auth.uid]) &&
        request.resource.data.admins.hasAny([request.auth.uid]);

      // Update basic group settings by admin only
      allow update: if isGroupAdmin() &&
        request.resource.data.keys().hasOnly([
          'name','description','profileImageUrl',
          'messagePermission','mediaPermission','allowMembersToAddOthers',
          'members','admins','updatedAt','createdAt','profileImageLocalPath'
        ]);

      // Members subcollection
      match /members/{userId} {
        allow get, list: if isGroupMember();
        allow create, update, delete: if isGroupAdmin();
      }
    }

    // Health Data collection
    match /users/{userId}/healthData/{healthId} {
      // Users can only access their own health data
      allow read, write: if request.auth != null && request.auth.uid == userId;
    }

    // Diet Files collection (global - for backward compatibility)
    match /dietFiles/{fileId} {
      // Users can read diet files (temporarily allow all authenticated users for queries)
      allow read: if request.auth != null;
      
      // Dietitians can create diet files for users
      allow create: if request.auth != null && 
        request.resource.data.dietitianId == request.auth.uid &&
        isDietitian(request.auth.uid);
      
      // Dietitians can update their own created files
      allow update: if request.auth != null && 
        resource.data.dietitianId == request.auth.uid &&
        isDietitian(request.auth.uid);
    }

    // Diet Files under user subcollection (recommended structure)
    match /users/{userId}/dietFiles/{fileId} {
      // Users can read their own diet files
      allow read: if request.auth != null && request.auth.uid == userId;
      
      // Dietitians can create diet files for users
      allow create: if request.auth != null && 
        request.resource.data.dietitianId == request.auth.uid &&
        isDietitian(request.auth.uid);
      
      // Dietitians can update their own created files
      allow update: if request.auth != null && 
        resource.data.dietitianId == request.auth.uid &&
        isDietitian(request.auth.uid);
    }

    // User Roles collection
    match /userRoles/{userId} {
      // Users can read their own role
      allow read: if request.auth != null;
      
      // TEMPORARY: Allow creating user roles for initial setup
      // TODO: Restrict to admins only after initial roles are set
      allow create, update: if request.auth != null;
    }

    // Diet Packages collection
    match /dietPackages/{packageId} {
      // Public packages can be read by everyone
      allow read: if request.auth != null && 
        (resource.data.isPublic == true || resource.data.dietitianId == request.auth.uid);
      
      // Only dietitians can create packages
      allow create: if request.auth != null && 
        isDietitian(request.auth.uid) &&
        request.resource.data.dietitianId == request.auth.uid;
      
      // Only package owner can update
      allow update: if request.auth != null && 
        resource.data.dietitianId == request.auth.uid &&
        isDietitian(request.auth.uid);
      
      // Only package owner can delete (if no active assignments)
      allow delete: if request.auth != null && 
        resource.data.dietitianId == request.auth.uid &&
        isDietitian(request.auth.uid);
    }

    // User Diet Assignments collection  
    match /userDietAssignments/{assignmentId} {
      // Users can read their own assignments, dietitians can read their created assignments
      allow read: if request.auth != null && (
        resource.data.userId == request.auth.uid ||
        (resource.data.dietitianId == request.auth.uid && isDietitian(request.auth.uid))
      );
      
      // Only dietitians can create assignments
      allow create: if request.auth != null && 
        isDietitian(request.auth.uid) &&
        request.resource.data.dietitianId == request.auth.uid;
      
      // Users can update their own data, dietitians can update assignments they created
      allow update: if request.auth != null && (
        (resource.data.userId == request.auth.uid && 
         request.resource.data.diff(resource.data).changedKeys().hasOnly([
           'userNotes', 'weightCurrent', 'userRating', 'userReview', 'isReviewed', 'updatedAt'
         ])) ||
        (resource.data.dietitianId == request.auth.uid && isDietitian(request.auth.uid))
      );
    }

    // Stories collection
    match /stories/{storyId} {
      // Allow reading active stories for authenticated users
      allow get, list: if request.auth != null && resource.data.isActive == true;

      // Owner can create their own story docs with constrained fields
      allow create: if request.auth != null &&
        request.resource.data.userId == request.auth.uid &&
        request.resource.data.keys().hasOnly([
          'storyId','userId','userPhone','userName','userProfileImage',
          'type','content','text','mediaUrl','thumbnailUrl','backgroundColor',
          'createdAt','expiresAt','isViewed','viewerIds','repliedUserIds',
          'isActive','visibilityMode','visibilityAllowed','visibilityExcluded',
          'viewers'
        ]) &&
        request.resource.data.storyId == storyId;

      // Updates
      allow update: if request.auth != null && (
        // Owner can update allowed meta fields
        (resource.data.userId == request.auth.uid &&
          request.resource.data.diff(resource.data).changedKeys().hasOnly([
            'userName','userProfileImage','isActive','viewerIds','repliedUserIds',
            'visibilityMode','visibilityAllowed','visibilityExcluded','viewers'
          ])
        ) ||
        // Any authenticated user can view stories (add themselves to viewer lists)
        (
          request.resource.data.diff(resource.data).changedKeys().hasOnly(['viewerIds','viewers']) &&
          request.resource.data.viewerIds is list &&
          request.resource.data.viewerIds.hasAny([request.auth.uid]) &&
          request.resource.data.viewers is map &&
          request.auth.uid in request.resource.data.viewers
        )
      );
    }

    // Calls collection (WebRTC signaling)
    match /calls/{callId} {
      // Participant helpers (for this call document)
      function isCaller() {
        return request.auth != null && resource.data.callerId == request.auth.uid;
      }
      function isCallee() {
        return request.auth != null && resource.data.calleeId == request.auth.uid;
      }
      function isParticipant() { return isCaller() || isCallee(); }

      // Only caller or callee can read/query a call
      allow get, list: if isParticipant();

      // Create by caller only, with constrained fields
      allow create: if request.auth != null &&
        request.resource.data.callerId == request.auth.uid &&
        request.resource.data.callId == callId &&
        request.resource.data.keys().hasOnly([
          'callId','callerId','calleeId','isVideo','status','createdAt','offer'
        ]);

      // Updates limited to participants: callee may attach answer; both may flip status/timestamps
      allow update: if isParticipant() &&
        request.resource.data.diff(resource.data).changedKeys().hasOnly([
          'answer','status','connectedAt','endedAt'
        ]) &&
        // immutable fields protection
        request.resource.data.callId == callId &&
        request.resource.data.callerId == resource.data.callerId &&
        request.resource.data.calleeId == resource.data.calleeId &&
        request.resource.data.isVideo == resource.data.isVideo;

      // Either side may delete their call doc
      allow delete: if isParticipant();

      // ICE candidates: only the respective side can add to its collection; both can read
      match /callerCandidates/{candidateId} {
        function parentIsCaller() {
          return request.auth != null &&
            get(/databases/$(database)/documents/calls/$(callId)).data.callerId == request.auth.uid;
        }
        function hasActiveCall() {
          return request.auth != null && (
            get(/databases/$(database)/documents/calls/$(callId)).data.status == 'ringing' ||
            get(/databases/$(database)/documents/calls/$(callId)).data.status == 'connected'
          );
        }
        function parentIsParticipant() {
          return request.auth != null && (
            get(/databases/$(database)/documents/calls/$(callId)).data.callerId == request.auth.uid ||
            get(/databases/$(database)/documents/calls/$(callId)).data.calleeId == request.auth.uid
          );
        }
        allow get, list: if parentIsParticipant();
        allow create: if parentIsCaller() && hasActiveCall() &&
          request.resource.data.keys().hasOnly(['candidate','sdpMid','sdpMLineIndex']);
      }

      match /calleeCandidates/{candidateId} {
        function parentIsCallee() {
          return request.auth != null &&
            get(/databases/$(database)/documents/calls/$(callId)).data.calleeId == request.auth.uid;
        }
        function hasActiveCall() {
          return request.auth != null && (
            get(/databases/$(database)/documents/calls/$(callId)).data.status == 'ringing' ||
            get(/databases/$(database)/documents/calls/$(callId)).data.status == 'connected'
          );
        }
        function parentIsParticipant() {
          return request.auth != null && (
            get(/databases/$(database)/documents/calls/$(callId)).data.callerId == request.auth.uid ||
            get(/databases/$(database)/documents/calls/$(callId)).data.calleeId == request.auth.uid
          );
        }
        allow get, list: if parentIsParticipant();
        allow create: if parentIsCallee() && hasActiveCall() &&
          request.resource.data.keys().hasOnly(['candidate','sdpMid','sdpMLineIndex']);
      }
    }
  }
}
