import 'package:flutter/material.dart';
import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:firebase_auth/firebase_auth.dart';
import '../models/chat_model.dart';
import '../models/message_model.dart';
import '../database/drift_service.dart';
import '../services/notification_service.dart';
import '../services/message_service.dart';
import '../services/tag_service.dart';
import '../services/contacts_service.dart';
import 'dart:async';

enum ChatFilter { all, unread, groups }

class ChatProvider extends ChangeNotifier {
  List<ChatModel> _chats = [];
  List<ChatModel> _filteredChats = [];
  ChatFilter _currentFilter = ChatFilter.all;
  bool _isLoading = false;
  String _searchQuery = '';

  // √áoklu se√ßim modu i√ßin yeni state'ler
  bool _isSelectionMode = false;
  List<String> _selectedChatIds = [];

  // Drift stream subscription for real-time UI updates
  StreamSubscription? _driftChatsSubscription;

  final FirebaseFirestore _firestore = FirebaseFirestore.instance;
  final FirebaseAuth _auth = FirebaseAuth.instance;

  // Getters
  List<ChatModel> get chats => _filteredChats;
  List<ChatModel> get archivedChats =>
      _chats.where((chat) => chat.isArchived).toList();
  ChatFilter get currentFilter => _currentFilter;
  bool get isLoading => _isLoading;
  String get searchQuery => _searchQuery;

  // √áoklu se√ßim modu getters
  bool get isSelectionMode => _isSelectionMode;
  List<String> get selectedChatIds => _selectedChatIds;
  int get selectedCount => _selectedChatIds.length;

  // Constructor - Yeni mimari: sadece Drift dinle
  ChatProvider() {
    _initializeChatProvider();
  }

  // Chat provider'ƒ± ba≈ülat
  Future<void> _initializeChatProvider() async {
    final user = _auth.currentUser;
    if (user == null) return;

    debugPrint('üöÄ ChatProvider baslatiliyor - Yeni mimari');

    // 1. Notification service callback'ini ayarla
    _setupNotificationCallback();

    // 2. ƒ∞lk a√ßƒ±lƒ±≈üta Firebase senkronizasyonunu arka plana al
    unawaited(_performInitialSyncFromFirebase());

    // 3. Drift'ten real-time chat listesi dinle
    _startListeningToLocalChats();

    // 4. ƒ∞lk chat listesini y√ºkle
    await loadChats();
  }

  // Notification service callback'ini ayarla
  void _setupNotificationCallback() {
    NotificationService.setNewMessageCallback(
      _handleNewMessageFromNotification,
    );
  }

  // Push notification'dan gelen yeni mesajƒ± i≈üle
  Future<void> _handleNewMessageFromNotification(
    String chatId,
    String messageId,
    Map<String, dynamic> messageData,
  ) async {
    await handleNewMessageNotification(
      chatId: chatId,
      messageId: messageId,
      messageData: messageData,
    );
  }

  // ƒ∞lk a√ßƒ±lƒ±≈üta Firebase'den t√ºm chatleri Isar'a senkronize et
  Future<void> _performInitialSyncFromFirebase() async {
    final user = _auth.currentUser;
    if (user == null) return;

    try {
      debugPrint('üîÑ Firebase ilk senkronizasyon baslatiliyor...');

      // Eƒüer daha √∂nce senkronize edildiyse aƒüƒ±r full fetch yerine sadece g√ºncellenenleri √ßek
      final lastLocalUpdate = _chats.isEmpty
          ? null
          : (_chats
              .map((c) => c.updatedAt)
              .whereType<DateTime>()
              .fold<DateTime?>(
                null,
                (p, e) => p == null || e.isAfter(p) ? e : p,
              ));

      Query<Map<String, dynamic>> query = _firestore
          .collection('chats')
          .where('participants', arrayContains: user.uid);

      if (lastLocalUpdate != null) {
        query = query.where('updatedAt',
            isGreaterThan: Timestamp.fromDate(lastLocalUpdate));
      }

      QuerySnapshot<Map<String, dynamic>> chatsSnapshot;
      try {
        chatsSnapshot = await query.get();
      } catch (e) {
        // √áevrimdƒ±≈üƒ±ysa sessizce yerel veriye d√º≈ü
        debugPrint(
            '‚ö†Ô∏è Firebase eri≈üilemedi, yerel Drift verisi kullanƒ±lacak: $e');
        _chats = await DriftService.getAllChats();
        _applyFilter();
        notifyListeners();
        return;
      }

      debugPrint('üì¶ Firebase ${chatsSnapshot.docs.length} chat bulundu');

      // Her chat'i Drift'e kaydet
      for (final doc in chatsSnapshot.docs) {
        await _syncSingleChatToDrift(doc.id, doc.data());
      }

      // ƒ∞lk giri≈ü optimizasyonu: son 7 g√ºne ait sohbetler ve her sohbetin son 100 mesajƒ±nƒ± √∂nceden indir
      try {
        final cutoff = DateTime.now().subtract(const Duration(days: 7));
        QuerySnapshot<Map<String, dynamic>>? recentChatsSnap;
        try {
          recentChatsSnap = await _firestore
              .collection('chats')
              .where('participants', arrayContains: user.uid)
              .where('updatedAt', isGreaterThan: Timestamp.fromDate(cutoff))
              .orderBy('updatedAt', descending: true)
              .get();
        } catch (e) {
          debugPrint('‚ö†Ô∏è Prefetch √ßevrimdƒ±≈üƒ±: $e');
          recentChatsSnap = null;
        }
        if (recentChatsSnap != null) {
          for (final chatDoc in recentChatsSnap.docs) {
            final chatId = chatDoc.id;
            await MessageService.prefetchLastMessagesToIsar(
              chatId: chatId,
              limit: 100,
            );
          }
        }
        debugPrint('‚úÖ Son 7 g√ºn sohbetleri ve son 100 mesaj √∂nbelleƒüe alƒ±ndƒ±');
      } catch (e) {
        debugPrint('‚ùå Prefetch sohbet/mesaj hatasƒ±: $e');
      }

      debugPrint('‚úÖ ƒ∞lk senkronizasyon tamamlandƒ±');
    } catch (e) {
      debugPrint('‚ùå ƒ∞lk senkronizasyon hatasƒ±: $e');
      // Tamamƒ±yla ba≈üarƒ±sƒ±zsa yine de yerel veriyi g√∂ster
      _chats = await DriftService.getAllChats();
      _applyFilter();
      notifyListeners();
    }
  }

  // Tek bir chat'i Firebase'den Drift'e senkronize et
  Future<void> _syncSingleChatToDrift(
    String chatId,
    Map<String, dynamic> chatData,
  ) async {
    try {
      final currentUserId = _auth.currentUser?.uid;
      if (currentUserId == null) return;

      final bool isGroup =
          (chatData['isGroup'] == true) || (chatData['type'] == 'group');

      ChatModel chat;
      if (isGroup) {
        // Grup chat modeli
        final dynamic perUser = chatData['unreadCountByUser'];
        final int perUserUnread = (perUser is Map<String, dynamic>)
            ? ((perUser[currentUserId] as num?)?.toInt() ?? 0)
            : 0;

        chat = ChatModel.createGroup(
          chatId: chatId,
          groupId: (chatData['groupId'] as String?) ?? chatId,
          groupName: (chatData['groupName'] as String?) ?? 'Grup',
          groupImage: chatData['groupImage'] as String?,
          groupDescription: chatData['groupDescription'] as String?,
          lastMessage: chatData['lastMessage'] as String?,
          isLastMessageFromMe:
              (chatData['isLastMessageFromMe'] as bool?) ?? false,
          isLastMessageRead: (chatData['isLastMessageRead'] as bool?) ?? false,
          unreadCount: perUserUnread,
        );

        // Timestamp'leri d√∂n√º≈üt√ºr
        if (chatData['lastMessageTime'] is Timestamp) {
          chat.lastMessageTime =
              (chatData['lastMessageTime'] as Timestamp).toDate();
        }
        if (chatData['createdAt'] is Timestamp) {
          chat.createdAt = (chatData['createdAt'] as Timestamp).toDate();
        }
        if (chatData['updatedAt'] is Timestamp) {
          chat.updatedAt = (chatData['updatedAt'] as Timestamp).toDate();
        }
      } else {
        // Bireysel chat modeli
        final participants = List<String>.from(chatData['participants'] ?? []);
        final otherUserId = participants.firstWhere(
          (id) => id != currentUserId,
          orElse: () => '',
        );
        if (otherUserId.isEmpty) return;

        final dynamic perUser = chatData['unreadCountByUser'];
        final int perUserUnread = (perUser is Map<String, dynamic>)
            ? ((perUser[currentUserId] as num?)?.toInt() ?? 0)
            : 0;

        chat = ChatModel.create(
          chatId: chatId,
          otherUserId: otherUserId,
          lastMessage: chatData['lastMessage'] ?? '',
          isLastMessageFromMe: chatData['isLastMessageFromMe'] ?? false,
          isLastMessageRead: chatData['isLastMessageRead'] ?? false,
          unreadCount: perUserUnread,
        );

        // Timestamp'leri d√∂n√º≈üt√ºr
        if (chatData['lastMessageTime'] is Timestamp) {
          chat.lastMessageTime =
              (chatData['lastMessageTime'] as Timestamp).toDate();
        }
        if (chatData['createdAt'] is Timestamp) {
          chat.createdAt = (chatData['createdAt'] as Timestamp).toDate();
        }
        if (chatData['updatedAt'] is Timestamp) {
          chat.updatedAt = (chatData['updatedAt'] as Timestamp).toDate();
        }

        // Sadece bireysel sohbetlerde kullanƒ±cƒ± bilgisi √ßek
        await _fetchAndSetUserInfo(chat, otherUserId);
      }

      // Yerel verilerle birle≈ütir
      final existingLocal = await DriftService.getChatById(chatId);
      if (existingLocal != null) {
        chat.tags = List<String>.from(existingLocal.tags);
        chat.isPinned = existingLocal.isPinned;
        chat.isMuted = existingLocal.isMuted;
        chat.isArchived = existingLocal.isArchived;
        if (!chat.isGroup) {
          if (existingLocal.otherUserContactName != null &&
              existingLocal.otherUserContactName!.isNotEmpty) {
            chat.otherUserContactName = existingLocal.otherUserContactName;
          }
          // Profil ismi/telefonu/fotoƒürafƒ± bo≈ü gelirse yereldekini koru
          if ((chat.otherUserProfileImage == null ||
                  chat.otherUserProfileImage!.isEmpty) &&
              (existingLocal.otherUserProfileImage != null &&
                  existingLocal.otherUserProfileImage!.isNotEmpty)) {
            chat.otherUserProfileImage = existingLocal.otherUserProfileImage;
          }
          if ((chat.otherUserName == null || chat.otherUserName!.isEmpty) &&
              (existingLocal.otherUserName != null &&
                  existingLocal.otherUserName!.isNotEmpty)) {
            chat.otherUserName = existingLocal.otherUserName;
          }
          if ((chat.otherUserPhoneNumber == null ||
                  chat.otherUserPhoneNumber!.isEmpty) &&
              (existingLocal.otherUserPhoneNumber != null &&
                  existingLocal.otherUserPhoneNumber!.isNotEmpty)) {
            chat.otherUserPhoneNumber = existingLocal.otherUserPhoneNumber;
          }
        }
        // Grup adƒ± ve g√∂rseli Firebase'den g√ºncel geliyorsa √ºzerine yaz, bo≈üsa yereldekini koru
        if (chat.isGroup) {
          if ((chat.groupName == null || chat.groupName!.isEmpty) &&
              (existingLocal.groupName != null &&
                  existingLocal.groupName!.isNotEmpty)) {
            chat.groupName = existingLocal.groupName;
          }
          if ((chat.groupImage == null || chat.groupImage!.isEmpty) &&
              (existingLocal.groupImage != null &&
                  existingLocal.groupImage!.isNotEmpty)) {
            chat.groupImage = existingLocal.groupImage;
          }
        }
      }

      await DriftService.saveChat(chat);
      debugPrint('üíæ Chat Drift e kaydedildi: $chatId');
    } catch (e) {
      debugPrint('‚ùå Chat senkronizasyon hatasƒ± ($chatId): $e');
    }
  }

  // Kullanƒ±cƒ± bilgilerini Firebase'den alƒ±p chat'e ata
  Future<void> _fetchAndSetUserInfo(ChatModel chat, String userId) async {
    try {
      final userDoc = await _firestore.collection('users').doc(userId).get();
      if (userDoc.exists) {
        final userData = userDoc.data();
        if (userData != null) {
          chat.otherUserName = userData['name'] ??
              userData['displayName'] ??
              'Firebase Kullanƒ±cƒ±sƒ±';
          chat.otherUserPhoneNumber = userData['phoneNumber'];
          chat.otherUserProfileImage =
              userData['profileImageUrl'] ?? userData['photoURL'];
          debugPrint('üë§ Kullanƒ±cƒ± bilgileri alƒ±ndƒ±: ${chat.otherUserName}');
        }
      } else {
        // Firebase'de kullanƒ±cƒ± bulunamadƒ±ysa varsayƒ±lan ad ata
        chat.otherUserName = 'Kullanƒ±cƒ± ($userId)';
        debugPrint('‚ö†Ô∏è Firebase\'de kullanƒ±cƒ± bulunamadƒ±: $userId');
      }
    } catch (e) {
      debugPrint('‚ùå Kullanƒ±cƒ± bilgisi alma hatasƒ±: $e');
      chat.otherUserName = 'Bilinmeyen Kullanƒ±cƒ±';
    }
  }

  // Lokal Drift veritabanƒ±nƒ± dinle (ger√ßek zamanlƒ± UI g√ºncellemesi)
  void _startListeningToLocalChats() {
    debugPrint('üëÇ Drift chat dinleyicisi baslatiliyor...');

    _driftChatsSubscription?.cancel();
    _driftChatsSubscription = DriftService.watchAllChats().listen(
      (chats) {
        debugPrint('üîÑ Drift ten ${chats.length} chat guncellendi');
        _chats = chats;
        _applyFilter();
        notifyListeners();
      },
      onError: (error) {
        debugPrint('‚ùå Drift chat dinleyici hatasƒ±: $error');
      },
    );
  }

  @override
  void dispose() {
    _driftChatsSubscription?.cancel();
    super.dispose();
  }

  // Manuel yenileme kaldƒ±rƒ±ldƒ± (Isar akƒ±≈üƒ± otomatik g√ºnceller)

  // Chat'leri veritabanƒ±ndan y√ºkle (sadece ilk a√ßƒ±lƒ±≈üta)
  Future<void> loadChats() async {
    if (_chats.isNotEmpty) {
      // Zaten y√ºkl√º, Isar listener otomatik g√ºncelleyecek
      return;
    }

    _isLoading = true;
    // Build frame i√ßindeyken notifyListeners √ßaƒüƒ±rmayƒ± engelle
    WidgetsBinding.instance.addPostFrameCallback((_) {
      notifyListeners();
    });

    try {
      _chats = await DriftService.getAllChats();

      // Chat'lerdeki rehber isimlerini g√ºncelle
      await _updateContactNames();

      _applyFilter();
      debugPrint('üîÑ Chat listesi ilk yukleme: ${_chats.length} chat');
    } catch (e) {
      debugPrint('Chat yukleme hatasi: $e');
    } finally {
      _isLoading = false;
      WidgetsBinding.instance.addPostFrameCallback((_) {
        notifyListeners();
      });
    }
  }

  // Push notification ile yeni mesaj geldiƒüinde √ßaƒürƒ±lacak
  Future<void> handleNewMessageNotification({
    required String chatId,
    required String messageId,
    required Map<String, dynamic> messageData,
  }) async {
    try {
      debugPrint('üîî Push notification: Yeni mesaj $messageId, Chat: $chatId');

      // √ñnce mesajƒ± Isar'a kaydet
      await _saveMessageToIsar(messageId, messageData);

      // Chat'i g√ºncelle ve kullanƒ±cƒ± bilgilerini al
      await _updateChatFromNewMessage(chatId, messageData);

      // Chat'in kullanƒ±cƒ± bilgilerini g√ºncelle
      await _updateChatUserInfo(chatId, messageData['senderId']);

      debugPrint('‚úÖ Push notification i≈ülendi');
    } catch (e) {
      debugPrint('‚ùå Push notification i≈üleme hatasƒ±: $e');
    }
  }

  // Mesajƒ± Isar'a kaydet
  Future<void> _saveMessageToIsar(
    String messageId,
    Map<String, dynamic> messageData,
  ) async {
    try {
      final message = MessageModel.create(
        messageId: messageId,
        chatId: messageData['chatId'] ?? '',
        senderId: messageData['senderId'] ?? '',
        content: messageData['text'] ?? '',
        type: MessageType.text,
        status: MessageStatus.delivered,
      );

      if (messageData['timestamp'] != null) {
        message.timestamp = (messageData['timestamp'] as Timestamp).toDate();
      }

      await DriftService.saveMessage(message);
      debugPrint('üíæ Mesaj Drift e kaydedildi: $messageId');
    } catch (e) {
      debugPrint('‚ùå Mesaj Drift kayit hatasi: $e');
    }
  }

  // Chat'i yeni mesajla g√ºncelle
  Future<void> _updateChatFromNewMessage(
    String chatId,
    Map<String, dynamic> messageData,
  ) async {
    try {
      ChatModel? chat = await DriftService.getChatById(chatId);
      if (chat == null) {
        // Firestore'dan chat'i getir ve Isar'a senkronize et
        try {
          final chatDoc =
              await _firestore.collection('chats').doc(chatId).get();
          if (chatDoc.exists) {
            await _syncSingleChatToDrift(chatId, chatDoc.data()!);
            chat = await DriftService.getChatById(chatId);
          }
        } catch (e) {
          debugPrint(
              '‚ö†Ô∏è Push ile gelen mesajda chat senkronizasyon hatasƒ±: $e');
        }
        if (chat == null) {
          debugPrint('‚ö†Ô∏è Chat bulunamadi: $chatId');
          return;
        }
      }

      final currentUserId = _auth.currentUser?.uid;
      final isFromCurrentUser = messageData['senderId'] == currentUserId;

      // Chat'i g√ºncelle
      chat.lastMessage = messageData['text'] ?? '';
      chat.isLastMessageFromMe = isFromCurrentUser;
      // Kendi mesajlarƒ±mƒ±z i√ßin okunmu≈ü kabul; kar≈üƒ± tarafƒ±n mesajƒ±ysa aktif ekranda ise okunmu≈ü say
      final bool isActiveThisChat = MessageService.isChatPageActive &&
          MessageService.activeChatId == chatId;
      chat.isLastMessageRead = isFromCurrentUser || isActiveThisChat;

      if (messageData['timestamp'] != null) {
        chat.lastMessageTime = (messageData['timestamp'] as Timestamp).toDate();
      }

      // Eƒüer mesaj ba≈ükasƒ±ndan ise ve bu chat aktif deƒüilse unread count'u artƒ±r
      if (!isFromCurrentUser) {
        if (isActiveThisChat) {
          chat.unreadCount = 0; // aktif ekranda: okunmu≈ü kabul
        } else {
          chat.unreadCount = chat.unreadCount + 1;
        }
      }

      chat.updatedAt = DateTime.now();

      await DriftService.updateChatModel(chat);

      // Aktif ekranda gelen mesaj ise, per-user unread'ƒ± ve mesajlarƒ± da okundu yap (arka planda)
      if (!isFromCurrentUser && isActiveThisChat) {
        try {
          await MessageService.markChatMessagesAsRead(chatId);
        } catch (_) {}
      }
      debugPrint('üìä Chat guncellendi: ${chat.chatId}');
    } catch (e) {
      debugPrint('‚ùå Chat guncelleme hatasi: $e');
    }
  }

  // Sadece belirli bir chat'i Firebase'den sync et (push notification ile)
  Future<void> syncSingleChatFromFirebase(String chatId) async {
    try {
      debugPrint('üîÑ Tek chat sync: $chatId');

      final chatDoc = await _firestore.collection('chats').doc(chatId).get();
      if (chatDoc.exists) {
        await _syncSingleChatToDrift(chatId, chatDoc.data()!);
        debugPrint('‚úÖ Chat sync tamamlandi: $chatId');
      }
    } catch (e) {
      debugPrint('‚ùå Chat sync hatasi: $e');
    }
  }

  // Chat'lere filtre uygula
  void _applyFilter() {
    switch (_currentFilter) {
      case ChatFilter.all:
        _filteredChats = _chats
            .where((chat) => !chat.isArchived)
            .where(
              (chat) =>
                  _searchQuery.isEmpty ||
                  (chat.otherUserContactName?.toLowerCase().contains(
                            _searchQuery.toLowerCase(),
                          ) ==
                      true) ||
                  (chat.lastMessage?.toLowerCase().contains(
                            _searchQuery.toLowerCase(),
                          ) ==
                      true),
            )
            .toList();
        break;
      case ChatFilter.unread:
        _filteredChats = _chats
            .where((chat) => !chat.isArchived && chat.unreadCount > 0)
            .where(
              (chat) =>
                  _searchQuery.isEmpty ||
                  (chat.otherUserContactName?.toLowerCase().contains(
                            _searchQuery.toLowerCase(),
                          ) ==
                      true) ||
                  (chat.lastMessage?.toLowerCase().contains(
                            _searchQuery.toLowerCase(),
                          ) ==
                      true),
            )
            .toList();
        break;
      case ChatFilter.groups:
        // Sadece grup chatlerini g√∂ster
        _filteredChats = _chats
            .where((chat) => !chat.isArchived && chat.isGroup)
            .where(
              (chat) =>
                  _searchQuery.isEmpty ||
                  (chat.groupName?.toLowerCase().contains(
                            _searchQuery.toLowerCase(),
                          ) ==
                      true) ||
                  (chat.lastMessage?.toLowerCase().contains(
                            _searchQuery.toLowerCase(),
                          ) ==
                      true),
            )
            .toList();
        break;
    }
  }

  // Filter deƒüi≈ütir
  void setFilter(ChatFilter filter) {
    _currentFilter = filter;
    _applyFilter();
    notifyListeners();
  }

  // Arama
  void setSearchQuery(String query) {
    _searchQuery = query;
    _applyFilter();
    notifyListeners();
  }

  // Chat'i okundu olarak i≈üaretle
  Future<void> markChatAsRead(String chatId) async {
    try {
      final chat = await DriftService.getChatById(chatId);
      if (chat != null && chat.unreadCount > 0) {
        chat.unreadCount = 0;
        chat.isLastMessageRead = true;
        await DriftService.updateChatModel(chat);
      }
    } catch (e) {
      debugPrint('‚ùå Chat okuma hatasƒ±: $e');
    }
  }

  // Chat'in kullanƒ±cƒ± bilgilerini g√ºncelle
  Future<void> _updateChatUserInfo(String chatId, String senderId) async {
    try {
      final chat = await DriftService.getChatById(chatId);
      if (chat == null) return;

      // Eƒüer g√∂nderen ID'si chat'teki other user ID'si deƒüilse g√ºncelle
      if (chat.otherUserId != senderId) {
        chat.otherUserId = senderId;
      }

      // Eƒüer kullanƒ±cƒ± adƒ± eksik, bo≈ü veya "Bilinmeyen" ise Firebase'den al
      bool needsUpdate = chat.otherUserName == null ||
          chat.otherUserName!.isEmpty ||
          chat.otherUserName == 'Bilinmeyen' ||
          chat.otherUserName == 'Bilinmeyen Kullanƒ±cƒ±';

      if (needsUpdate) {
        // Kullanƒ±cƒ± bilgilerini Firebase'den al
        final userDoc =
            await _firestore.collection('users').doc(senderId).get();
        if (userDoc.exists) {
          final userData = userDoc.data();
          if (userData != null) {
            // Kullanƒ±cƒ± bilgilerini g√ºncelle
            chat.otherUserName = userData['name'] ??
                userData['displayName'] ??
                'Firebase Kullanƒ±cƒ±sƒ±';
            chat.otherUserPhoneNumber = userData['phoneNumber'];
            chat.otherUserProfileImage =
                userData['profileImageUrl'] ?? userData['photoURL'];

            await DriftService.updateChatModel(chat);
            debugPrint(
              'üë§ Chat kullanƒ±cƒ± bilgileri g√ºncellendi: ${chat.otherUserName}',
            );
          }
        } else {
          // Firebase'de de kullanƒ±cƒ± bulunamadƒ±ysa varsayƒ±lan ad ata
          if (chat.otherUserName == null || chat.otherUserName!.isEmpty) {
            chat.otherUserName = 'Kullanƒ±cƒ± ($senderId)';
            await DriftService.updateChatModel(chat);
            debugPrint(
                'üë§ Varsayƒ±lan kullanƒ±cƒ± adƒ± atandƒ±: ${chat.otherUserName}');
          }
        }
      }
    } catch (e) {
      debugPrint('‚ùå Chat kullanƒ±cƒ± bilgisi g√ºncelleme hatasƒ±: $e');
    }
  }

  // Rehber isimlerini g√ºncelle
  Future<void> _updateContactNames() async {
    try {
      for (final chat in _chats) {
        final phone = chat.otherUserPhoneNumber;
        if (phone != null && phone.isNotEmpty) {
          final contactName = await ContactsService.getContactNameByPhone(
            phone,
          );
          if (contactName != null && contactName.isNotEmpty) {
            if (chat.otherUserContactName != contactName) {
              chat.otherUserContactName = contactName;
              await DriftService.updateChatModel(chat);
            }
          }
        }
      }
    } catch (e) {
      debugPrint('‚ùå Rehber g√ºncelleme hatasƒ±: $e');
    }
  }

  // Chat'leri yenile (manuel)
  Future<void> refreshChats() async {
    await loadChats();
  }

  // Chat'leri hemen y√ºkle (eski API uyumluluƒüu i√ßin)
  Future<void> loadChatsImmediately() async {
    await loadChats();
  }

  // Chat ekle veya g√ºncelle
  Future<void> addOrUpdateChat(ChatModel chat) async {
    try {
      await DriftService.saveChat(chat);
      debugPrint('üíæ Chat eklendi/g√ºncellendi: ${chat.chatId}');
    } catch (e) {
      debugPrint('‚ùå Chat ekleme/g√ºncelleme hatasƒ±: $e');
    }
  }

  // Chat'i sabitle/sabitlemeyi kaldƒ±r
  Future<void> togglePin(String chatId) async {
    try {
      final chat = await DriftService.getChatById(chatId);
      if (chat != null) {
        chat.isPinned = !chat.isPinned;
        await DriftService.updateChatModel(chat);

        // Firebase'e de g√ºncelle
        await _firestore.collection('chats').doc(chatId).update({
          'isPinned': chat.isPinned,
          'updatedAt': FieldValue.serverTimestamp(),
        });

        debugPrint(
          'üìå Chat pin durumu deƒüi≈ütirildi: ${chat.chatId} -> ${chat.isPinned}',
        );
      }
    } catch (e) {
      debugPrint('‚ùå Chat pin hatasƒ±: $e');
    }
  }

  // Chat'i sustur/susturmayƒ± kaldƒ±r
  Future<void> toggleMute(String chatId) async {
    try {
      final chat = await DriftService.getChatById(chatId);
      if (chat != null) {
        chat.isMuted = !chat.isMuted;
        await DriftService.updateChatModel(chat);

        // Firebase'e de g√ºncelle
        await _firestore.collection('chats').doc(chatId).update({
          'isMuted': chat.isMuted,
          'updatedAt': FieldValue.serverTimestamp(),
        });

        debugPrint(
          'üîá Chat mute durumu deƒüi≈ütirildi: ${chat.chatId} -> ${chat.isMuted}',
        );
      }
    } catch (e) {
      debugPrint('‚ùå Chat mute hatasƒ±: $e');
    }
  }

  // Chat'i ar≈üivle/ar≈üivden √ßƒ±kar
  Future<void> toggleArchive(String chatId) async {
    try {
      final chat = await DriftService.getChatById(chatId);
      if (chat != null) {
        chat.isArchived = !chat.isArchived;
        await DriftService.updateChatModel(chat);

        // Firebase'e de g√ºncelle
        await _firestore.collection('chats').doc(chatId).update({
          'isArchived': chat.isArchived,
          'updatedAt': FieldValue.serverTimestamp(),
        });

        debugPrint(
          'üì¶ Chat ar≈üiv durumu deƒüi≈ütirildi: ${chat.chatId} -> ${chat.isArchived}',
        );
      }
    } catch (e) {
      debugPrint('‚ùå Chat ar≈üiv hatasƒ±: $e');
    }
  }

  // Chat'i benden gizle (soft-delete) - Firestore kurallarƒ± gereƒüi t√ºm chati silme yok
  Future<void> deleteChat(String chatId) async {
    try {
      final user = _auth.currentUser;
      if (user == null) return;

      // Yerelde chat'i kaldƒ±r
      await DriftService.deleteChat(chatId);

      // Firestore'da kullanƒ±cƒ±ya √∂zel i≈üaretle
      await _firestore.collection('chats').doc(chatId).set({
        'deletedFor': {user.uid: true},
        'deletedAtByUser': {user.uid: FieldValue.serverTimestamp()},
        'updatedAt': FieldValue.serverTimestamp(),
      }, SetOptions(merge: true));

      debugPrint('üóëÔ∏è Chat benden gizlendi: $chatId');
    } catch (e) {
      debugPrint('‚ùå Chat silme hatasƒ±: $e');
    }
  }

  // T√ºm etiketleri getir
  List<String> getAllTags() {
    final tags = <String>{};
    for (final chat in _chats) {
      tags.addAll(chat.tags);
    }
    return tags.toList()..sort();
  }

  // Belirli etikete sahip chat'leri getir
  List<ChatModel> getChatsWithTag(String tag) {
    return _chats.where((chat) => chat.tags.contains(tag)).toList();
  }

  // Birden √ßok etikete g√∂re filtrele (hepsini i√ßeren)
  List<ChatModel> getChatsWithTags(List<String> tagIds,
      {bool anyMatch = true}) {
    if (tagIds.isEmpty) return _chats;
    return _chats.where((chat) {
      if (anyMatch) {
        return chat.tags.any((t) => tagIds.contains(t));
      } else {
        // hepsini i√ßersin
        return tagIds.every((t) => chat.tags.contains(t));
      }
    }).toList();
  }

  // T√ºm chat'lerden etiketi kaldƒ±r
  Future<void> removeTagFromAllChats(String tag) async {
    try {
      for (final chat in _chats) {
        if (chat.tags.contains(tag)) {
          chat.tags.remove(tag);
          await DriftService.updateChatModel(chat);

          // Firebase'e de g√ºncelle
          await _firestore.collection('chats').doc(chat.chatId).update({
            'tags': chat.tags,
            'updatedAt': FieldValue.serverTimestamp(),
          });
        }
      }
      debugPrint('üè∑Ô∏è Etiket t√ºm chat\'lerden kaldƒ±rƒ±ldƒ±: $tag');
    } catch (e) {
      debugPrint('‚ùå Etiket kaldƒ±rma hatasƒ±: $e');
    }
  }

  // ==================== √áOKLU SE√áƒ∞M MODU FONKSƒ∞YONLARI ====================

  // √áoklu se√ßim modunu ba≈ülat
  void enterSelectionMode(String chatId) {
    _isSelectionMode = true;
    _selectedChatIds = [chatId];
    notifyListeners();
  }

  // √áoklu se√ßim modundan √ßƒ±k
  void exitSelectionMode() {
    _isSelectionMode = false;
    _selectedChatIds.clear();
    notifyListeners();
  }

  // Chat'i se√ßime ekle/√ßƒ±kar
  void toggleChatSelection(String chatId) {
    if (_selectedChatIds.contains(chatId)) {
      _selectedChatIds.remove(chatId);
      // Eƒüer hi√ß se√ßili chat kalmadƒ±ysa se√ßim modundan √ßƒ±k
      if (_selectedChatIds.isEmpty) {
        exitSelectionMode();
      }
    } else {
      _selectedChatIds.add(chatId);
    }
    notifyListeners();
  }

  // Chat se√ßili mi kontrol et
  bool isChatSelected(String chatId) {
    return _selectedChatIds.contains(chatId);
  }

  // T√ºm chat'leri se√ß
  void selectAllChats() {
    _selectedChatIds = _filteredChats.map((chat) => chat.chatId).toList();
    notifyListeners();
  }

  // ==================== TOPLU ƒ∞≈ûLEMLER ====================

  // Se√ßili chat'leri sabitle/sabitlemeyi kaldƒ±r
  Future<void> togglePinForSelected() async {
    try {
      for (final chatId in _selectedChatIds) {
        await togglePin(chatId);
      }
      exitSelectionMode();
    } catch (e) {
      debugPrint('‚ùå Toplu sabitleme hatasƒ±: $e');
    }
  }

  // Se√ßili chat'leri sessizle/sesini a√ß
  Future<void> toggleMuteForSelected() async {
    try {
      for (final chatId in _selectedChatIds) {
        await toggleMute(chatId);
      }
      exitSelectionMode();
    } catch (e) {
      debugPrint('‚ùå Toplu sessizlik hatasƒ±: $e');
    }
  }

  // Se√ßili chat'leri ar≈üivle/ar≈üivden √ßƒ±kar
  Future<void> toggleArchiveForSelected() async {
    try {
      for (final chatId in _selectedChatIds) {
        await toggleArchive(chatId);
      }
      exitSelectionMode();
      debugPrint(
        'üì¶ Toplu ar≈üiv i≈ülemi tamamlandƒ±: ${_selectedChatIds.length} sohbet',
      );
    } catch (e) {
      debugPrint('‚ùå Toplu ar≈üiv hatasƒ±: $e');
    }
  }

  // Se√ßili chat'leri sil
  Future<void> deleteSelectedChats() async {
    try {
      final List<String> chatsToDelete = List.from(_selectedChatIds);
      for (final chatId in chatsToDelete) {
        await deleteChat(chatId);
      }
      exitSelectionMode();
    } catch (e) {
      debugPrint('‚ùå Toplu silme hatasƒ±: $e');
    }
  }

  // Se√ßili chat'lere etiket ekle
  Future<void> addTagToSelected(List<String> tagIds) async {
    try {
      final tagService = TagService();

      for (final chatId in _selectedChatIds) {
        for (final tagId in tagIds) {
          await tagService.addTagToChat(chatId, tagId);
        }
      }

      // Local cache'i g√ºncelle
      await loadChats();
      exitSelectionMode();
      debugPrint(
        'üè∑Ô∏è Etiketler eklendi: ${tagIds.length} etiket, ${_selectedChatIds.length} sohbet',
      );
    } catch (e) {
      debugPrint('‚ùå Toplu etiket ekleme hatasƒ±: $e');
    }
  }

  // Se√ßili chat'lerden etiket kaldƒ±r
  Future<void> removeTagFromSelected(String tagId) async {
    try {
      final tagService = TagService();

      for (final chatId in _selectedChatIds) {
        await tagService.removeTagFromChat(chatId, tagId);
      }

      // Local cache'i g√ºncelle
      await loadChats();
      exitSelectionMode();
      debugPrint('üè∑Ô∏è Etiket kaldƒ±rƒ±ldƒ±: $tagId');
    } catch (e) {
      debugPrint('‚ùå Toplu etiket kaldƒ±rma hatasƒ±: $e');
    }
  }

  // Tek chat'e etiket ekle
  Future<void> addTagToChat(String chatId, String tagId) async {
    try {
      final tagService = TagService();
      await tagService.addTagToChat(chatId, tagId);

      // Local cache'i g√ºncelle
      await loadChats();
      debugPrint('üè∑Ô∏è Etiket eklendi: $tagId -> $chatId');
    } catch (e) {
      debugPrint('‚ùå Etiket ekleme hatasƒ±: $e');
    }
  }

  // Tek chat'den etiket kaldƒ±r
  Future<void> removeTagFromChat(String chatId, String tagId) async {
    try {
      final tagService = TagService();
      await tagService.removeTagFromChat(chatId, tagId);

      // Local cache'i g√ºncelle
      await loadChats();
      debugPrint('üè∑Ô∏è Etiket kaldƒ±rƒ±ldƒ±: $tagId <- $chatId');
    } catch (e) {
      debugPrint('‚ùå Etiket kaldƒ±rma hatasƒ±: $e');
    }
  }

  // Se√ßili chat'leri okundu/okunmadƒ± olarak i≈üaretle
  Future<void> markSelectedAsRead(bool isRead) async {
    try {
      for (final chatId in _selectedChatIds) {
        final chat = _chats.firstWhere((c) => c.chatId == chatId);
        if (isRead) {
          chat.unreadCount = 0;
          chat.isLastMessageRead = true;
        } else {
          chat.unreadCount = 1;
          chat.isLastMessageRead = false;
        }
        await DriftService.updateChatModel(chat);
      }
      exitSelectionMode();
    } catch (e) {
      debugPrint('‚ùå Toplu okuma durumu hatasƒ±: $e');
    }
  }
}
